import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="1. Fundamentals of Programming/1.2 Data Types & Operations/1.2.5 Lists/1.2.5.3 Solutions" />

# 1.2.5.3 Lists - Solutions

This page provides solutions and explanations for all the list tasks. Each solution includes the complete code and a detailed explanation of how it works.

---

## Easy

### Implement

#### 1. Create a simple list — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-1.1.png"
  alt="Create a simple list"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
sensor_readings = [25, 30, 28]

# The main program starts here.
print(sensor_readings)
```

Explanation:

- We create a list using the list literal constructor with three sensor values.
- The square brackets `[]` define the list, and commas separate the elements.
- Printing the list shows all elements enclosed in brackets.

Expected output:

```
[25, 30, 28]
```

#### 2. Get list length — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-1.2.png"
  alt="Get list length"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
robot_tasks = ["startup", "scan", "move", "stop"]

# The main program starts here.
print(len(robot_tasks))
```

Explanation:

- We create a list with four string elements representing robot tasks.
- The `len()` function returns the number of elements in the list.
- The list has 4 elements, so `len()` returns 4.

Expected output:

```
4
```

#### 3. Access first element — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-1.3.png"
  alt="Access first element"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
coordinates = [100, 50, 25]

# The main program starts here.
print(coordinates[0])
```

Explanation:

- We create a list with three coordinate values.
- Using `coordinates[0]` accesses the first element (index 0 in zero-based indexing).
- The first element is 100, representing the x-coordinate.

Expected output:

```
100
```

### Predict

#### 4. List indexing — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-1.1.png"
  alt="List indexing prediction"
  style={{ width: "50%" }}
/>

Code:

```python
colors = ["red", "green", "blue"]
print(colors[0])
print(colors[2])
print(len(colors))
```

Step-by-step analysis:

- `colors[0]` → "red" (first element at index 0)
- `colors[2]` → "blue" (third element at index 2)
- `len(colors)` → 3 (the list has 3 elements)

Expected output:

```
red
blue
3
```

#### 5. Range constructor — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-1.2.png"
  alt="Range constructor prediction"
  style={{ width: "50%" }}
/>

Code:

```python
numbers = range(4)
print(list(numbers))
speeds = range(10, 30, 5)
print(list(speeds))
```

Step-by-step analysis:

- `range(4)` → creates 0, 1, 2, 3 (from 0 up to but not including 4)
- `range(10, 30, 5)` → creates 10, 15, 20, 25 (from 10 to 30, step by 5)

Expected output:

```
[0, 1, 2, 3]
[10, 15, 20, 25]
```

#### 6. Mixed data types — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-1.3.png"
  alt="Mixed data types prediction"
  style={{ width: "50%" }}
/>

Code:

```python
robot_info = ["Robot-01", 85, True]
print(robot_info[0])
print(robot_info[1])
print(len(robot_info))
```

Step-by-step analysis:

- `robot_info[0]` → "Robot-01" (string at index 0)
- `robot_info[1]` → 85 (integer at index 1)
- `len(robot_info)` → 3 (the list has 3 elements of different types)

Expected output:

```
Robot-01
85
3
```

---

## Medium

### Implement

#### 7. Update list element — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-2.1.png"
  alt="Update list element"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
battery_levels = [75, 80, 65]

# The main program starts here.
battery_levels[2] = 90
print(battery_levels)
```

Explanation:

- We create a list with three battery level values.
- Using `battery_levels[2] = 90` updates the third element (index 2) to 90.
- The updated list now shows [75, 80, 90] instead of the original [75, 80, 65].

Expected output:

```
[75, 80, 90]
```

#### 8. Range with custom step — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-2.2.png"
  alt="Range with custom step"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
custom_range = range(0, 20, 4)

# The main program starts here.
print(list(custom_range))
```

Explanation:

- `range(0, 20, 4)` creates numbers from 0 up to (but not including) 20, stepping by 4.
- This generates: 0, 4, 8, 12, 16 (stops before 20).
- Converting to a list with `list()` allows us to see all values at once.

Expected output:

```
[0, 4, 8, 12, 16]
```

#### 9. Unpack coordinates — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-2.3.png"
  alt="Unpack coordinates"
  style={{ width: "50%" }}
/>

Solution (code):

```python
# Initialize variables.
position = [150, 75, 30]
x = 0  # Must initialize before unpacking
y = 0  # Must initialize before unpacking
z = 0  # Must initialize before unpacking

# The main program starts here.
x, y, z = position
print(x)
print(y)
print(z)
```

Explanation:

- We create a position list with three coordinates.
- The variables x, y, z must be initialized before unpacking.
- `x, y, z = position` assigns position[0] to x, position[1] to y, position[2] to z.
- Each coordinate is now available as a separate variable.

Expected output:

```
150
75
30
```

### Predict

#### 10. List modification — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-2.1.png"
  alt="List modification prediction"
  style={{ width: "75%" }}
/>

Code:

```python
temperatures = [22, 25, 28]
print(temperatures)
temperatures[1] = 30
print(temperatures)
print(len(temperatures))
```

Step-by-step analysis:

- First print shows the original list: [22, 25, 28]
- `temperatures[1] = 30` changes the middle element from 25 to 30
- Second print shows the modified list: [22, 30, 28]
- `len(temperatures)` is still 3 (length doesn't change when updating elements)

Expected output:

```
[22, 25, 28]
[22, 30, 28]
3
```

#### 11. Range with negative step — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-2.2.png"
  alt="Range with negative step prediction"
  style={{ width: "75%" }}
/>

Code:

```python
countdown = range(5, 0, -1)
print(list(countdown))
zero_to_ten = range(11)
print(len(list(zero_to_ten)))
```

Step-by-step analysis:

- `range(5, 0, -1)` counts down from 5 to 1 (stops before 0): [5, 4, 3, 2, 1]
- `range(11)` creates 0 through 10 (11 numbers total)
- `len(list(zero_to_ten))` returns 11

Expected output:

```
[5, 4, 3, 2, 1]
11
```

#### 12. Complex unpacking — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-2.3.png"
  alt="Complex unpacking prediction"
  style={{ width: "75%" }}
/>

Code:

```python
sensor_data = [25, "active", True]
temp = 0
status = ""
online = False
temp, status, online = sensor_data
print(temp)
print(status)
print(online)
```

Step-by-step analysis:

- Variables are initialized with default values
- `temp, status, online = sensor_data` unpacks the list
- temp gets 25, status gets "active", online gets True

Expected output:

```
25
active
True
```

---

## Hard

### Implement

#### 13. Multi-step list operations — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-3.1.png"
  alt="Multi-step list operations"
  style={{ width: "75%" }}
/>

Solution (code):

```python
# Initialize variables.
waypoints = [10, 25, 40]

# The main program starts here.
waypoints[1] = 35
print(waypoints[0])
print(len(waypoints))
```

Explanation:

- We create a waypoint list and update the second element (index 1) from 25 to 35.
- `waypoints[0]` accesses the first element, which is still 10.
- `len(waypoints)` returns 3 since the list still has 3 elements.

Expected output:

```
10
3
```

#### 14. Range calculation — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-3.2.png"
  alt="Range calculation"
  style={{ width: "75%" }}
/>

Solution (code):

```python
# Initialize variables.
speed_range = range(50, 100, 15)
speed_list = list(speed_range)

# The main program starts here.
print(speed_list)
print(len(speed_list))
```

Explanation:

- `range(50, 100, 15)` creates: 50, 65, 80, 95 (stops before 100).
- Converting to a list allows us to see the values and count them.
- The length is 4 because there are 4 values in the range.

Expected output:

```
[50, 65, 80, 95]
4
```

#### 15. Coordinate manipulation — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-3.3.png"
  alt="Coordinate manipulation"
  style={{ width: "75%" }}
/>

Solution (code):

```python
# Initialize variables.
coordinates = [200, 150, 100]
x = 0  # Must initialize before unpacking
y = 0  # Must initialize before unpacking
z = 0  # Must initialize before unpacking

# The main program starts here.
x, y, z = coordinates
coordinates[1] = x
print(coordinates)
```

Explanation:

- We unpack the coordinates to get x=200, y=150, z=100.
- Then we update coordinates[1] (the y-coordinate) with the x value (200).
- The final list becomes [200, 200, 100].

Expected output:

```
[200, 200, 100]
```

### Predict

#### 16. Advanced list operations — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-3.1.png"
  alt="Advanced list operations prediction"
  style={{ width: "100%" }}
/>

Code:

```python
data = [5, 10, 15, 20]
data[2] = data[0] + data[1]
print(data)
print(data[2] == 15)
print(len(data) > 3)
```

Step-by-step analysis:

- `data[2] = data[0] + data[1]` → `data[2] = 5 + 10` → data[2] becomes 15
- Updated list: [5, 10, 15, 20]
- `data[2] == 15` → True (the new value is 15)
- `len(data) > 3` → True (length is 4, which is greater than 3)

Expected output:

```
[5, 10, 15, 20]
True
True
```

#### 17. Range edge cases — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-3.2.png"
  alt="Range edge cases prediction"
  style={{ width: "100%" }}
/>

Code:

```python
empty_range = range(0)
print(len(list(empty_range)))
single_range = range(1)
print(list(single_range))
reverse_range = range(3, 0, -2)
print(list(reverse_range))
```

Step-by-step analysis:

- `range(0)` creates an empty range, length is 0
- `range(1)` creates [0] (one element: 0)
- `range(3, 0, -2)` counts down from 3: 3, 1 (stops before 0)

Expected output:

```
0
[0]
[3, 1]
```

#### 18. Multiple unpacking — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-3.3.png"
  alt="Multiple unpacking prediction"
  style={{ width: "100%" }}
/>

Code:

```python
rgb1 = [255, 128, 0]
rgb2 = [0, 255, 128]
r1 = g1 = b1 = 0
r2 = g2 = b2 = 0
r1, g1, b1 = rgb1
r2, g2, b2 = rgb2
print(r1 + r2)
print(g1 == g2)
```

Step-by-step analysis:

- After unpacking: r1=255, g1=128, b1=0, r2=0, g2=255, b2=128
- `r1 + r2` → 255 + 0 = 255
- `g1 == g2` → 128 == 255 → False

Expected output:

```
255
False
```

---

## Challenge

### Implement

#### 19. Robot status system — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-4.1.png"
  alt="Robot status system"
  style={{ width: "100%" }}
/>

Solution (code):

```python
# Initialize variables.
status = ["Robot-01", 85, "active", True]

# The main program starts here.
status[1] = 92
status[2] = "charging"
print(status[0])
print(len(status))
```

Explanation:

- We update the battery level (index 1) to 92 and status (index 2) to "charging".
- `status[0]` prints the robot ID "Robot-01".
- `len(status)` returns 4 since the list still has 4 elements.

Expected output:

```
Robot-01
4
```

#### 20. Sensor array processing — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-4.2.png"
  alt="Sensor array processing"
  style={{ width: "100%" }}
/>

Solution (code):

```python
# Initialize variables.
temps1 = [22, 25, 28]
temps2 = [22, 25, 28]  # Same values

# The main program starts here.
print(temps1[0] == temps2[0])
```

Explanation:

- We create two lists with identical values.
- Comparing the first elements: 22 == 22 is True.
- This demonstrates that lists can hold the same data and be compared element by element.

Expected output:

```
True
```

#### 21. Complex coordinate system — solution and explanation

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/SOL-4.3.png"
  alt="Complex coordinate system"
  style={{ width: "100%" }}
/>

Solution (code):

```python
# Initialize variables.
position = [100, 200, 50]
x = 0  # Must initialize before unpacking
y = 0  # Must initialize before unpacking
z = 0  # Must initialize before unpacking

# The main program starts here.
x, y, z = position
rotated = [z, x, y]
print(position[0])
print(rotated[0])
```

Explanation:

- We unpack the original position to get x=100, y=200, z=50.
- Create a rotated list with the order [z, x, y] = [50, 100, 200].
- Print the first coordinate of original (100) and rotated (50) lists.

Expected output:

```
100
50
```

### Predict

#### 22. Ultimate list challenge — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-4.1.png"
  alt="Ultimate list challenge prediction"
  style={{ width: "100%" }}
/>

Code:

```python
matrix = [1, 2, 3]
matrix[1] = matrix[0] * matrix[2]
x = y = z = 0
x, y, z = matrix
new_matrix = [z, y, x]
print(matrix)
print(new_matrix)
print(len(matrix) == len(new_matrix))
```

Step-by-step analysis:

- `matrix[1] = matrix[0] * matrix[2]` → matrix[1] = 1 \* 3 = 3, so matrix = [1, 3, 3]
- After unpacking: x=1, y=3, z=3
- `new_matrix = [z, y, x]` → [3, 3, 1]
- Both lists have length 3, so the comparison is True

Expected output:

```
[1, 3, 3]
[3, 3, 1]
True
```

#### 23. Range arithmetic — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-4.2.png"
  alt="Range arithmetic prediction"
  style={{ width: "100%" }}
/>

Code:

```python
steps = list(range(2, 10, 2))
print(steps)
doubled = []
doubled = [steps[0] * 2, steps[1] * 2, steps[2] * 2, steps[3] * 2]
print(doubled)
print(len(steps) == len(doubled))
```

Step-by-step analysis:

- `range(2, 10, 2)` → [2, 4, 6, 8]
- `doubled` becomes [4, 8, 12, 16] (each element \* 2)
- Both lists have length 4, so the comparison is True

Expected output:

```
[2, 4, 6, 8]
[4, 8, 12, 16]
True
```

#### 24. Complex data flow — solution and explanation

This references the blocks shown in the predict task:

<img
  src="/1-fundamentals-of-programming/1.2-data-types-operations/1.2.5-lists/res/PRED-4.3.png"
  alt="Complex data flow prediction"
  style={{ width: "100%" }}
/>

Code:

```python
sensors = ["temp", "humidity", "pressure"]
values = [25, 60, 1013]
combined = [sensors[0], values[0], sensors[1], values[1]]
print(len(combined))
sensor_name = status_value = ""
sensor_name, status_value = combined[0], combined[1]
print(sensor_name)
print(status_value)
```

Step-by-step analysis:

- `combined` = ["temp", 25, "humidity", 60] (4 elements)
- `len(combined)` → 4
- `sensor_name, status_value = combined[0], combined[1]` → "temp", 25

Expected output:

```
4
temp
25
```
